(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{444:function(i,v,_){"use strict";_.r(v);var l=_(44),t=Object(l.a)({},(function(){var i=this,v=i.$createElement,_=i._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[_("p",[i._v("给定一个包含非负整数的 mxn的矩阵 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。")]),i._v(" "),_("p",[i._v("说明：每次只能向下或者向右移动一步。")]),i._v(" "),_("p",[i._v("题解：")]),i._v(" "),_("p",[i._v("此题是典型的动态规划的题目。")]),i._v(" "),_("ul",[_("li",[i._v("状态定义：\n"),_("ul",[_("li",[i._v("设dp为大小 "),_("code",[i._v("m x n")]),i._v(" 矩阵，其中"),_("code",[i._v("dp[i][j]")]),i._v("的值代表直到走到"),_("code",[i._v("(i,j)")]),i._v("的最小路径和。")])])]),i._v(" "),_("li",[i._v("转移方程:")])]),i._v(" "),_("blockquote",[_("p",[i._v("题目要求，只能向右或者向下走，换句话说，当前单元格（i，j）只能从左方单元格 （i-1,j）或者上方单元格（i，j-1）走到，因此只需要考虑矩阵左边界和上边界。")])]),i._v(" "),_("ul",[_("li",[i._v('走到当前单元格（i，j）的最小路径和 = "从左方单元格（i-1, j）"与从上方单元格（i，j-1）走来的两个最小路径中较小的” + 当前单元格值[i][j] 具体分为以下四种情况。\n'),_("ul",[_("li",[i._v("1 当左边和上边都不是矩阵的边界时：即当 i !== 0  j !== 0 dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]")])])])])])}),[],!1,null,null,null);v.default=t.exports}}]);