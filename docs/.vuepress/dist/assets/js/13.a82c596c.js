(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{359:function(v,_,e){v.exports=e.p+"assets/img/01.f95a0dc2.png"},396:function(v,_,e){"use strict";e.r(_);var t=e(44),c=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"ci-cd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd"}},[v._v("#")]),v._v(" CI/CD")]),v._v(" "),t("h2",{attrs:{id:"什么是ci-cd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是ci-cd"}},[v._v("#")]),v._v(" 什么是CI/CD")]),v._v(" "),t("p",[v._v("在开发阶段，许多编译工具会将我们的源码编译成可使用的文件。例如 "),t("code",[v._v("vue-cli")]),v._v("的项目被 "),t("code",[v._v("webpack")]),v._v("打包编译为浏览器可识别的文件，"),t("code",[v._v("Java")]),v._v(" 项目会被编译为 "),t("code",[v._v(".class/jar")]),v._v("文件以供服务器使用。")]),v._v(" "),t("p",[v._v("但是开发人员过多关注构建和部署过程是很浪费时间的。以之前古老的构建部署流程为例，需要经历以下步骤：")]),v._v(" "),t("ul",[t("li",[v._v("1.开发人员将源代码，经过编译、压缩等一系列流程打包为制品（打包后的成品）。")]),v._v(" "),t("li",[v._v("2.将打包好的文件传到服务器")]),v._v(" "),t("li",[v._v("3.在服务器将编译后的文件，手动移动到可用的容器服务内（例如 "),t("code",[v._v("Nginx Tomcat Apache")]),v._v("等服务）")])]),v._v(" "),t("p",[t("img",{attrs:{src:e(359),alt:"流程"}})]),v._v(" "),t("p",[v._v("显而易见，这种流程不仅繁琐，且容易出错，是非常影响开发效率的。开发人员要花一些时间浪费在这上面，有没有提高效率，简单便捷一些方式呢？")]),v._v(" "),t("p",[v._v("这就要提到"),t("code",[v._v("CI/CD")]),v._v("了。 "),t("code",[v._v("CI")]),v._v("的意思是"),t("code",[v._v("持续构建")]),v._v("。负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个 "),t("code",[v._v("制品")]),v._v('，并将制品推送到制品库里面，常用的工具有Gitlab CI, Github CI, Jenkins等，这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称作制品，保存制品的地方被称为"制品库"')]),v._v(" "),t("p",[v._v("CD则有两层含义："),t("code",[v._v("持续部署(Continuous Deployment)")]),v._v(" 和 "),t("code",[v._v("持续交付(Continuous Delivery)")]),v._v("。 "),t("code",[v._v("持续交付")]),v._v("的概念是：将制品库的制品拿出后，部署在测试环境/交付给客户提前测试。"),t("code",[v._v("持续部署")]),v._v("则是将制品部署在生产环境，可以进行持续部署的工具也有很多："),t("code",[v._v("Ansible")]),v._v("批量部署，"),t("code",[v._v("Docker")]),v._v("直接推拉镜像等等。当然也包括我们后面写道的 "),t("code",[v._v("Kubernetes")]),v._v(" 集群部署。")]),v._v(" "),t("h2",{attrs:{id:"整体完成之后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整体完成之后"}},[v._v("#")]),v._v(" 整体完成之后")]),v._v(" "),t("ul",[t("li",[v._v("1.写完了代码，提交到了"),t("code",[v._v("Git")]),v._v("代码仓库。")]),v._v(" "),t("li",[v._v("2.随后，代码仓库配置的 "),t("code",[v._v("WebHook")]),v._v(" 钩子或者人工启动了 "),t("code",[v._v("JenKins")]),v._v(" 的构建流程。")]),v._v(" "),t("li",[v._v("3.Jenkins 启动构建流程。按照你之前配置好的构建脚本，将代码编译成功。")]),v._v(" "),t("li",[v._v("4.编译成功后，将编译后的文件打包为 docker 镜像，并将镜像上传到私有镜像仓库。")]),v._v(" "),t("li",[v._v("5.随后，使用 kubectl 指定远程的k8s集群，发送镜像版本更新指令")]),v._v(" "),t("li",[v._v("6.远程的k8s集群接收到指令后，去镜像库拉取新镜像")]),v._v(" "),t("li",[v._v("7.镜像拉取成功，按照升级策略（滚动升级）进行升级，此时不会停机。")]),v._v(" "),t("li",[v._v("8.升级完毕。")])])])}),[],!1,null,null,null);_.default=c.exports}}]);