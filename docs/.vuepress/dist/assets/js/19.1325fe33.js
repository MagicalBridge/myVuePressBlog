(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{382:function(t,e,v){"use strict";v.r(e);var s=v(44),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"一、vue中的组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、vue中的组件"}},[t._v("#")]),t._v(" 一、vue中的组件")]),t._v(" "),v("h3",{attrs:{id:"写在前面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[t._v("#")]),t._v(" 写在前面")]),t._v(" "),v("p",[t._v("vue.js 最精髓的，正是它的组件与组件化，写一个vue工程，也正是写一个个的组件。")]),t._v(" "),v("p",[t._v("业务场景千变万化，而不变的是vue.js组件的核心思想使用技巧，掌握了vue.js组件的各种开发模式，再复杂的场景也可以应对。")]),t._v(" "),v("h3",{attrs:{id:"组件的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件的分类"}},[t._v("#")]),t._v(" 组件的分类")]),t._v(" "),v("p",[t._v("一般来说，vue.js 组件主要分为三类：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("由 vue-router 产生的每个页面，本质上也是一个组件 （.vue），主要承载当前页面的HTML结构，包含数据的获取、数据整理、数据可视化等常规业务。整个文件相对较大，但是一般不会有 "),v("code",[t._v("props")]),t._v(" 选项和"),v("code",[t._v("自定义事件")]),t._v(",因为它作为路由的渲染，不会被复用，因此也不会对外提供接口。在项目开发中，我们写的大部分代码都是这类组件（页面），协同开发时候，每个人维护自己的页面，很少有交集。这类组件相对好些，因为主要是还原设计稿，完成需求，不需要太多模块和架构设计上的考虑。")])]),t._v(" "),v("li",[v("p",[t._v("不包含业务，独立、具体功能的基础组件，比如、模态框等。这类组件作为项目的基础控件，会被大量使用，因此组价你的API进行过高强度的抽象，可以通过不同的配置实现不同的功能。独立组件的开发难度要高于第一类组件，因为它的侧重点是API的设计、兼容性、性能，以及复杂的功能。 这类组件对JavaScript的编程能力有一定的要求，也会包含非常多的技巧，比如在不依赖 Vuex 和 Bus(因为独立组件，无法依赖其他库)的情况下，各组件的通信、还会涉及到很多其他问题。")])]),t._v(" "),v("li",[v("p",[t._v("业务组件。它不像第二类独立组件只包含某个功能，而是在业务中被多个页面复用的，它与独立组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而独立组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。业务组件更像是介于第一类和第二类之间，在开发上也与独立组件类似，但寄托于项目，你可以使用项目中的技术栈，比如 Vuex、axios、echarts 等，所以它的开发难度相对独立组件要容易点，但也有必要考虑组件的可维护性和复用性。")])])]),t._v(" "),v("h2",{attrs:{id:"二、vue中的三个api-prop、event、slot"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、vue中的三个api-prop、event、slot"}},[t._v("#")]),t._v(" 二、vue中的三个API: prop、event、slot")]),t._v(" "),v("h3",{attrs:{id:"组件的构成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件的构成"}},[t._v("#")]),t._v(" 组件的构成")]),t._v(" "),v("p",[t._v("一个再复杂的组件，都是由三个部分组成：prop、event、slot，它们构成了vue.js的组价的API,如果你开发的是一个通用组件，那一定要事先设计好这三部分，因为组件一旦发布，后面再修改 API 就很困难了，使用者都是希望不断新增功能，修复 bug，而不是经常变更接口。如果你阅读别人写的组件，也可以从这三个部分展开，它们可以帮助你快速了解一个组件的所有功能。")]),t._v(" "),v("h4",{attrs:{id:"属性-prop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-prop"}},[t._v("#")]),t._v(" 属性 prop")]),t._v(" "),v("p",[v("code",[t._v("prop")]),t._v("定义了这个组件有哪些可配置的属性，组件的核心功能也都是它来确定的。写通用组件时，props 最好用"),v("strong",[t._v("对象")]),t._v("的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，这点在组件开发中很重要，然而很多人却忽视，直接使用 props 的数组用法，这样的组件往往是不严谨的。比如我们封装一个按钮组件 "),v("i-button",[t._v("：")])],1)])}),[],!1,null,null,null);e.default=r.exports}}]);