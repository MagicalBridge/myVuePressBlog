---
sidebar: auto
---

# 04.寻找两个正序数组的中位数
[题目描述](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/)

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log(m+n))。

示例 1：
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

示例 2：
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

## 算法思路
这个解法的思路是利用归并排序的思想，将两个正序数组合并成一个有序数组，然后找到中位数，具体步骤如下。
- 1、计算两个数的长度和，以及中位数的下标 k.
- 2、用两个指针 i 和 j 分别指向两个数组的开头。
- 3、依次比较两个指针所指的元素，将较小的元素加入到合并后的数组中，并将指针移动到下一位。
- 4、如果已经找到了中位数，就返回中位数，如果还没有找到，就继续比较，直到找到中位数为止。

这个解法的时间复杂度是 O(m+n) 其中m和n分别是两个数组的长度，空间复杂度是O(1), 因为只需要用常数个变量来保存中间结果。

```ts
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  // 首先计算两个数组的长度
  const m = nums1.length;
  const n = nums2.length;
  // 计算长度的加和
  const total = m + n;
  // 判断加和是不是偶数
  const isEven = total % 2 === 0;
  // 找到中间位置的索引下标
  const k = Math.floor(total / 2);

  // i 和 j 分别指向的是两个数组的开头
  let i = 0;
  let j = 0;
  // 合并后的数组的前一个元素 和当前元素
  let prev = 0;
  let curr = 0;

  // for循环 
  for (let l = 0; l <= k; l++) {
    prev = curr;
    if (i < m && (j >= n || nums1[i] < nums2[j])) {
      curr = nums1[i];
      i++;
    } else {
      curr = nums2[j];
      j++;
    }
  }

  return isEven ? (prev + curr) / 2 : curr;
}
```

在代码中，我们首先计算了两个数组的长度和中位数的下标，设置了一个变量 isEven 判断总的长度是否为偶数，然后用两个指针 i 和 j分别指向两个数组的开头，用一个循环依次比较两个指针的位置，将较小的元素加入到合并后的数组，并将指针向后移动一位，在循环中我们用变量 prev 和 curr分别保存上一个元素和当前的元素，以便在找到中位数的时候计算中位数的值。最后根据isEven 的值返回中位数。

