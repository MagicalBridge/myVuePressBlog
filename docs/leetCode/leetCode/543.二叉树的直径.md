给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

```
    1
   / \
  2   3
 / \    
4   5    
```
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。


## 方法一
根据题目的描述可以得出这样的结论：一条路径的长度为该路径经过的节点数减一。所以求直径（求路径长度的最大值）等效于求路径经过节点的最大值减一。

而任意一条零均可以被看做由某个节点为起点，从其左边儿子和右边儿子向下遍历的路径拼接而成。

题目中也强调了这一点，可以不经过根节点。

```
      1
     / \
    2   3
   / \    
   4  5
  /  / \
 9  7   6
    /
   8
```

如图我们可以看到路径 [9, 4, 2, 5, 7, 8] 可以被看做是以2为起点，从其左儿子向下遍历的路径 [2, 4, 9]，和从其右儿子向下遍历的路径 [2, 5, 7, 8] 拼接得到。

假设我们知道对于该节点的左儿子向下遍历经过最多的节点数L（即以左儿子为根的子树的深度）和其右儿子向下遍历经过做多的节点数 R（即以右儿子为根的子树的深度），那么该节点为起点的路径经过节点的最大值即为 L + R + 1

我们的算法流程：

我们记节点 node 为起点的路径经过节点数的最大值为 dnode 那么二叉树的直径就是所有节点 dnode的最大值减一。（每个节点都应该遍历到）

最后的算法流程为：我们定义一个递归函数 depth() 计算 dnode 函数返回该节点为根的子树的深度,先递归调用左儿子和右儿子求得它们为根的子树的深度 LL 和 RR ，则该节点为根的子树的深度即为 max(L,R)+1 。

该节点值为 L+R+1 

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
// 给定一颗二叉树,你需要计算它的直径长度，一颗二叉树的直径长度是任意两个节点路径长度中的最大值
// 这条路径可能穿过也可能不穿过根节点。
let ans;
var depth = function (node) {
  if (node == null) {
    return 0; // 访问到空节点了，返回0
  }
  let L = depth(node.left); // 左儿子为根的子树的深度
  let R = depth(node.right); // 右儿子为根的子树的深度
  ans = Math.max(ans, L + R + 1); // 计算d_node即L+R+1 并更新ans
  return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
}
var diameterOfBinaryTree = function (root) {
  ans = 1;
  depth(root);
  return ans - 1;
};
```






