## 70.爬楼梯
[题目描述](https://leetcode-cn.com/problems/climbing-stairs/)

> 标签：记忆化搜索、数学、动态规划

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

示例 2：
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

题解:
1、爬楼梯问题 可以先通过找规律的方法来进行梳理：

- 有1级台阶，1、有一种方法，也就是爬一级。总共1种方法。
- 有2级台阶，1、第一次爬1级，第二次爬1级;  2、或者一次爬2级，总共2种方法。
- 有3级台阶，1、一级一级的爬；2、先爬一级，再爬两级；3、先爬两级，再爬一级  总共3中方法。
- 有4级台阶，1、一级一级的爬；2、先爬一级，再爬一级，最后爬两级；3、先爬两级，再爬一级，最后爬一级；4、先爬一级，再爬两级，最后爬一级，5、先爬两级，再爬两级

通过上述这种找规律，我们可以看到，爬到n阶，要么从n-1阶爬一级，要么从n-2阶爬两级，从上面的4级台阶的例子，我们可以从3级台阶向上爬一级，也可以从2级台阶向上爬2级。

可以得出递推公式：f(x) = f(x-1)+ f(x-2)。不难想出使用递归的方式, 代码如下：
```js
/**
 * @param {number} n
 * @return {number}
 */
// 这题是动态规划问题，动态规划问题的核心是自底想上的解决问题
var climbStairs = function (n) {
  if (n ===1) {
    return 1
  }
  if (n === 2) {
    return 2
  }
  return climbStairs(n-1) + climbStairs(n-2)
};
```

我们可以用一颗树来表示上面代码的执行过程：
![递归树](../../images/leetcode/70/01.png)

从树中的构造中可以看到，有很多重复的部分，这些重复的部分是可以进行优化的，具体的思路是，我们可以准备一个记忆数组，将计算过的节点，存入数组中，下次再用到这个节点数据的时候直接从数组中取出来就好，不需要重复计算了。

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
	// 准备一个记忆数组
  let memo = [];
	// memo[0] 代表 数组第0位也就是只有一级台阶的情况
  memo[0] = 1;
	// memo[1] 代表 数组第1位也就是两级台阶的情况 
  memo[1] = 1;
  for (let i = 2; i <= n;i++) {
    memo[i] = memo[i-1]+ memo[i-2];
  }
  return memo[n]
};
```