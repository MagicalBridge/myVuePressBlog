## 71.简化路径

## 题目描述

给你一个字符串 `path` ，表示指向某一文件或目录的`Unix`风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中:
- 一个点（.）表示当前目录本身；
- 两个点 （..）表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。
- 任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 
- 任何其他格式的点（例如，'...'）均被视为文件/目录名称。

## 注意：返回的规范路径必须遵循下述格式：
- 始终以斜杠 '/' 开头。
- 两个目录名之间必须只有一个斜杠 '/' 。
- 最后一个目录名（如果存在）不能 以 '/' 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。

## 方法一：栈

思路与算法：

我们首先将给定的字符串 path 根据 / 分割成一个由若干个字符串组成的列表，记为 names, 根据题目中规定的「规范路径的下述格式」names中包含的字符串只能为以下几种：
- 空字符串，例如当出现多个连续的 / 就会出现空字符串。
- 一个点 . ;
- 两个点 .. ;
- 只包含英文字母、数字或者 _ 的目录名。

对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」标识当前的目录本身，我们无需切换目录。

对于两个点 或者 目录名 我们可以用一个栈来维护路径中的每一个目录名。当我们遇到两个点是，需要将目录切换到上一个层级，因此只要栈不为空，我们就要弹出栈顶的目录，当我们遇到目录名时候，就把它放入栈。

这样一来，我们只需要遍历 names 中的每个字符串并进行上述操作，在所有的操作完成之后，我们将从栈底到栈顶的字符串用 / 进行连接，再在最前面加上/表示根目录，就可以得到简化后的规范路径。

```js
var simplifyPath = function(path) {
  const names = path.split("/")
  const stack = []

  for (const name of names) {
    if (name === "..") {
      if (stack.length) {
        stack.pop()
      }
    } else if (name.length && name !== ".") {
      stack.push(name)
    }
  }
  return "/"+stack.join("/")
}
```

## 复杂度分析
- 时间复杂度：O(n)，其中 n 是字符串 path 的长度。
- 空间复杂度：O(n)。我们需要 O(n) 的空间存储 names 中的所有字符串。


