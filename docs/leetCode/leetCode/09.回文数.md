---
sidebar: auto
---

# 09.回文数
[题目描述](https://leetcode.cn/problems/palindrome-number/)
::: tip
标签：数学
:::

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

例如，121 是回文，而 123 不是。
 

示例 1：
```
输入：x = 121
输出：true
```

示例 2：
```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

示例 3：
```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

## 算法思路：
第一个想法是将【数字】转换为【字符串】，并检查字符串是否为回文。但是，这需要创建额外的空间，问题描述中已经说明不要使用字符串。

第二个想法是将【数字本身】反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于Number类型所能承载的最大值，我们将遇到整数溢出问题。

按照第二种思路，为了避免数字反转可能导致的溢出问题，我们可以考虑只反转数字的一半，因为，如果该数字是回文，它的后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们可以得出结论：数字 1221 是回文。

### 详细步骤：
首先，我们应该处理一些临界情况：
- 1、所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false；
- 2、除了 0 以外，所有个位是 0 的数字不可能是回文数，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字。

对于数字 1221，如果执行 `1221 % 10`, 我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先将数字除以10，然后利用取整的方式将最后一位数字从 1221 中移除，`Math.floor(1221 / 10) = 122`，再拿这个结果对10取余数，`122 % 10 = 2`，就可以得到倒数第二位数字。

接着，我们可以把最后一位数字乘以 10，再加上倒数第二位数字，`1 * 10 + 2 = 12`，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

```ts
var isPalindrome = function(x: number): boolean {
  // 特殊情况：
  // 如上所述，当 x < 0 时，x 不是回文数。
  // 同样地，如果数字的最后一位是 0，为了使该数字为回文，则其第一位数字也应该是 0
  // 只有 0 满足这一属性
  if (x < 0 || (x % 10 === 0 && x !== 0)) {
    return false;
  }

  let revertedNumber: number = 0;
  // 当反转后的数字大于或者等于原始数字时，说明已经处理了一半位数的数字了
  while (x > revertedNumber) {
    revertedNumber = revertedNumber * 10 + x % 10;
    x = Math.floor(x / 10);
  }

  // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
  // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
  // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
  return x === revertedNumber || x === Math.floor(revertedNumber / 10);
};
```

### 附录：
1、在 JavaScript 中，"%" 是取模运算符，也被称为**取余运算符**。它返回除法操作的余数。例如，`11 % 3` 的结果是 2，因为 11 除以 3 等于 3，余数是 2。取模运算通常用于确定一个数是偶数还是奇数，或者用于周期性的计算。





