给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

示例1:
```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

题解:
本题是一道非常经典且历史悠久的动态规划题目。在本题中，给定的三角形行数是n,并且第i行(从0开始编号)包含了 i+1 个数。如果将每一行的左端对其，那么会形成一个等腰直角三角形 如下面所示

```
[2]
[3,4]
[6,5,7]
[4,1,8,3]
```

我们用 **`f[i][j]`表示从三角形顶部走到位置`(i)(j)`的最小路径和**。 这里的(i,j)指的是三角形中第i行第j列（均从0）开始编号的位置。

由于每一步只能移动到下一行 「相邻的节点」上，因此要想走到位置（i,j）上一步就只能在位置 (i-1,j-1) 或者位置（i-1,j），我们可以用上面这个数组的例子来类比，假设我们走到数组的第四行第二个位置1，我们只能从数组第三行第一个位置6，或者数组第三行第二个位置5，走下去。换成坐标语言，就是从走到(4,2)这个位置，我们只能从（3，2）或者（3，1）走过去。因此我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：

```
f[i][j] = min(f[i-1][j-1],f[i-1][j]) + c[i][j]
```

**其中c[i][j]表示位置(i)(j)对应的元素值。**

注意：第i行有i+1个元素，第0行有1个元素，第3行有4个元素。它们对应的j的范围为[0,i]，当j = 0或者 j = i 时候，上述状态转移方程中有一些是没有意义的。例如当j = 0时候，`f[i-1][j-1]` 没有意义, 因为j-1取不到元素了。

因此状态转移方程为：
```
f[i][0] = f[i−1][0] + c[i][0]
```
即，当我们在第 i 行的最左侧的时候，我们只能从第 i-1 行的最左侧移动过来。

当 j = i时候，f[i-1][j], 没有意义, 因此状态转移方程为：
```
f[i][i] = f[i−1][i−1] + c[i][i]
```
即：当我们在第 i 行的最右侧时候，我们只能从第i-1行的最右侧移动过来。

最终的答案即为 f[n-1][0] 到 f[n-1][n-1] 中的最小值 其中n 是三角形的行数。

细节：状态转移方程的边界条件是什么？ 由于我们已经去除了所有的「没有意义」的状态，因此边界条件可以定为：

f[0][0] = c[0][0]: 在三角形的顶部，最小的路径和就等于对应位置的元素值，这样一来，我们从 1 开始递增地枚举 i，并在 [[0,i] 的范围内递增地枚举 j，就可以完成所有状态的计算。

当然这道题目还可以从下往上查找

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
  // 索引都是从0开始的 bottom 是最后一行 [4,1,8,3]
  const bottom = triangle[triangle.length - 1]
  // 创建一个和bottom 长度一样的数组 
  const dp = new Array(bottom.length)

  for(let i = 0; i < dp.length; i++ ) {
    dp[i] = bottom[i]
  }
  // 循环赋值之后 dp 变成： [4,1,8,3]

  // 从倒数第二列开始迭代
  for(let i = dp.length-2; i >= 0; i--) {
    for(let j = 0; j < triangle[i].length; j++) {
      dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j];
    }
  }
  return dp[0];
};
```


