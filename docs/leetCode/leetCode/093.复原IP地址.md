---
sidebar: auto
---

# 093.复原IP地址


## 题目描述
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 都是有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是无效IP地址。
给定一个只包含数字的字符串s，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按任何顺序返回答案。

示例：
```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]

输入：s = "0000"
输出：["0.0.0.0"]

输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

## 思路

以 "25525511135" 为例，第一步时我们有几种选择？选择的依据就是每个位置至少要有一数字，最多有三个
  - 1- 选 "2" 作为第一个片段
  - 2- 选 "25" 作为第一个片段
  - 3- 选 "255" 作为第一个片段

通过上面的列举我们可以看到，第一步我们可以切三种不同的长度，切第二个片段的时候，又面临三种选择。

这样就会向下产生分支，形成一棵树，我们使用DFS去遍历所有的选择，必要时提前回溯，因为某一步的选择可能是错误的，得不到正确的结果，不要往下走了，撤销最后一步选择，回到选择前的状态，去尝试另一个选择。

回溯的要点：
- 1 选择，它展开了一颗空间树
- 2 约束，约束条件限制了当前的选项，这道题目的约束条件是：
  - 一个片段长度是 1~3
  - 片段的值的范围是 0~255
  - 不能是0x、00x 形式
- 3 目标，
  - 目标决定了什么时候捕获答案，什么时候砍掉死的分支，回溯
  - 目标是生成4个有效片段，并且要耗尽IP的字符
  - 当条件满足时候，说明生成了一个有效组合，加入解集，结束当前递归，继续探索别的分支
  - 如果满足4个有效片段，但是没有耗尽字符，不是想要的解，不继续往下递归，提前回溯

我们利用这些约束条件，充分的进行剪枝去掉一些选择，避免搜索 「不会产生答案」的分支

定义dfs函数
- dfs函数传递什么？也就是 用什么描述一个节点的状态？
- 选择切出一个片段后，继续递归剩余子串，可以传指针，加上当前的片段数组，描述节点的状态。
- dfs函数做的事情：复原从start到末尾的子串。

```js
const restoreIpAddresses = (s) => { 
  const res = [];
  // 复原从start开始的子串
  const dfs = (subRes, start) => {                 
    if (subRes.length == 4 && start == s.length) { // 片段满4段，且耗尽所有字符
      res.push(subRes.join('.'));                  // 拼成字符串，加入解集
      return;                     // 返不返回都行，指针已经到头了，严谨的说还是返回
    }
    if (subRes.length == 4 && start < s.length) {  // 满4段，字符未耗尽，不用往下选了
      return;
    }
    for (let len = 1; len <= 3; len++) {           // 枚举出选择，三种切割长度
      if (start + len - 1 >= s.length) return;     // 加上要切的长度就越界，不能切这个长度
      if (len != 1 && s[start] == '0') return;     // 不能切出'0x'、'0xx'

      const str = s.substring(start, start + len); // 当前选择切出的片段
      if (len == 3 && +str > 255) return;          // 不能超过255

      subRes.push(str);                            // 作出选择，将片段加入subRes
      dfs(subRes, start + len);                    // 基于当前选择，继续选择，注意更新指针
      subRes.pop(); // 上面一句的递归分支结束，撤销最后的选择，进入下一轮迭代，考察下一个切割长度
    }
  };

  dfs([], 0); // dfs入口
  return res;
};
```

## 思考：
我自己感觉这也是个全排列的问题。







