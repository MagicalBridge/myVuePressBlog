---
sidebar: auto
---

# 200.岛屿数量
[题目描述](https://leetcode.cn/problems/number-of-islands/)

::: tip
标签: 数组、矩阵、深度优先搜索
:::

## 算法思路
在力扣中，「岛屿问题」是一系列的问题，比如：
```
200. 岛屿数量 （Medium）
463. 岛屿的周长 （Easy）
695. 岛屿的最大面积 （Medium）
827. 最大人工岛 （Hard）
```

我们所熟悉的DFS(深度优先搜索)问题通常是在树或者图结构上进行的。这里我们讨论的DFS是在「网格」中进行的，岛屿问题是这类网格DFS问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS代码容易写的冗长复杂。

### 网格问题的基本概念

我们首先要明确一下岛屿问题中的网格结构是如何定义的，以便后面进行讨论。

网格问题是由 `m×n` 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。


岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。

![网格问题定义](../../images/leetcode/200/01.jpeg)

在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。


### DFS的基本结构
网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：

```java
void traverse(TreeNode root) {
  // 判断 base case
  if (root == null) {
    return;
  }
  // 访问两个相邻结点：左子结点、右子结点
  traverse(root.left);
  traverse(root.right);
}
```

可以看到，二叉树的 DFS 有两个要素：「访问相邻结点」和「判断 base case」。

第一个要素是访问相邻结点。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。

第二个要素是判断**base case**, 一般来说，二叉树遍历的base case是 `root == null`, 这样一个条件判断有两个含义，一方面，这表示 root 指向的子树为空，不需要再往下遍历了，另一方面，在 `root == null` 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。











