描述: 设计LRU缓存（最近最少使用）缓存结构，该结构在构造时确定大小，假设大小为K
，并且有如下两个功能
- 1 set(key, value), 将记录（key, value）插入该结构
- 2 get(key): 返回key 对应的value的值。

提示：
- 1 某个key的set或者get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。
- 2 当缓存的大小超过k时候，移除最不经常使用的记录
- 3 输入一个二维数组与k,二维数组每一维有2个或者3个数字，第一个数字为opt，第2，3个数字为 key value
  - 若opt=1，接下来两个整数key, value，表示set(key, value)
  - 若opt=2，接下来一个整数key，表示get(key)，若key未出现过或已被移除，则返回-1
- 4 为了方便区分缓存里面的key 和value 下面说明的缓存里的key用 ""包裹

示例1：
```
输入：
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3

返回值：
[1,-1]

说明：
[1,1,1]，第一个1表示opt=1，要set(1,1)，即将(1,1)插入缓存，缓存是{"1"=1}
[1,2,2]，第一个1表示opt=1，要set(2,2)，即将(2,2)插入缓存，缓存是{"1"=1,"2"=2}
[1,3,2]，第一个1表示opt=1，要set(3,2)，即将(3,2)插入缓存，缓存是{"1"=1,"2"=2,"3"=2}
[2,1]，第一个2表示opt=2，要get(1)，返回是[1]，因为get(1)操作，缓存更新，缓存是{"2"=2,"3"=2,"1"=1}
[1,4,4]，第一个1表示opt=1，要set(4,4)，即将(4,4)插入缓存，但是缓存已经达到最大容量3，移除最不经常使用的{"2"=2}，插入{"4"=4}，缓存是{"3"=2,"1"=1,"4"=4}
[2,2]，第一个2表示opt=2，要get(2)，查找不到，返回是[1,-1] 
```

这道题目有两个点需要注意，在二维数组中，子数组如果第一个元素是1，例如 [1,1,1], 这种代表的是塞值操作, 数组中的第二个元素和第三个元素分别代表的是key 和 value。 所以 [1,1,1]代表的操作是set(1,1), [2,1]，第一个2表示取值操作，要get(1)，返回是[1]，因为get(1)操作，缓存更新，缓存是{"2"=2,"3"=2,"1"=1} 这个说明非常有意思，取值操作结束后，最新取值的的会放在最后面。下次再进行操作的时候，会将最新的key也是放在最后。

总结一句话，最新取值操作的key放在最后，最新塞值的key也放在最后，如果塞值的时候发现空间不够了，这个时候应该做的就是将开头的值去除掉。

取值和塞值，我们应该使用一个map来作为映射表。缓存的顺序，我们使用一个数组来维持这个顺序。

具体实现逻辑是，
- 环遍历二维数组, 通过判断子数组的第一个数字是1还是2 做分流操作。
- 如果是 1 代表的是设置缓存的操作
  - 将当前的key value 放入map 中。
- 如果是 2 代表的是取出缓存的操作
```js
/**
 * lru design
 * @param operators int整型二维数组 the ops
 * @param k int整型 the k
 * @return int整型一维数组
 */
function LRU( operators ,  k ) {
  let map = new Map(); // 存放数字之间的映射
  let res = [] // 存放操作结果的数组
  let list = [] // 缓存队列

  // 对数组使用for in 循环 返回的 item 是数组的索引
  for(let item in operators) {
    let op = operators[item][0]; // 每个数组的第一项是操作方式
    if(op === 1 ) { // 代表的是存值操作
      // 存入map中，map 中保存着所有关系的映射
      map.set(operators[item][1],operators[item][2])
      // 在存值操作时候如果发现已经超出队列的容量
      if(list.length >= k) {
        // 将缓存队列的队尾删除，这个是使用频率最少的
        list.shift();
      }
      // 将新的值放入队头
      list.push(operators[item][1])
    } else if(op === 2) { // 代表的是取值操作
      let key = operators[item][1];
      // 判断key在缓存队列中是否存在
      let index = list.indexOf(key); 
      
      if(index === -1)  { // 说明不存在
        res.push(-1)
      } else { // 如果在缓存队列中存在
        res.push(map.get(key)) // 存放的是value
        list.splice(index,1) // 更新当前的这个key到队列的队头
        list.push(key)
      }
    }
  }
  return res
}
```
