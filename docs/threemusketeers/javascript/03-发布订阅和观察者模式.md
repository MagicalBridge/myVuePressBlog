---
sidebar: auto
---

# 发布订阅和观察者模式

发布订阅模式的顺序：先订阅 --> 再发布

发布订阅模式 核心就是把多个方法先暂存起来，最后一次执行，这样的做法能够解耦。

发布订阅模式首先需要有个事件中心：
```js
const fs = require("fs")
const path = require("path")

let events = {
  _events: [],
  on(fn) {
    this._events.push(fn)
  },
  emit(data) {
    this._events.forEach((fn) => fn(data))
  },
}
```
上面代码中有一个`event`对象,其中包含两个方法, `on`方法和`emit`方法。

如何订阅呢？

```js
// on 方法中传入的是一个函数。
events.on(() => {
  console.log("每emit一次 就触发一次")
})

let arr = []
events.on((data) => {
  console.log("每emit一次 就push一次")
  arr.push(data)
})

events.on(() => {
  if (arr.length === 2) {
    // 最终结果还是计数器
    console.log("读取完毕", arr)
  }
})
```
上面代码中，我订阅三个方法，这三个方法，会被缓存在 _events 数组中。上面函数执行完毕，_events数组中应该三个函数。

```js
fs.readFile(path.resolve(__dirname, "./a.txt"), "UTF8", function (err, data) {
  if (!err) {
    events.emit(data)
  }
})
fs.readFile(path.resolve(__dirname, "./b.txt"), "UTF8", function (err, data) {
  if (!err) {
    events.emit(data)
  }
})
```

上面使用fs模块的读取文件的方法，异步的从文件系统中读取文件，读取文件之后, 触发发布放方法，并且传入参数。

发布订阅之间是没有依赖关系的，特别是对于上面的代码来说，发布是一个异步的操作，会先执行订阅，再会走到发布的代码。

