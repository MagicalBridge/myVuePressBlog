---
sidebar: auto
---
# 注册命令部分

## 选用commander作为注册命令的工具

为了学习`commander`这个npm包的用法，我新建了一个npm项目，需要注意的是:

- 一定要在文件开始声明解析模块 `#! /usr/bin/env node`
- 添加 bin 字段 注册命令为：commander
- npm link 进行全局注册

## commander 最基础用法

```js
#! /usr/bin/env node
const commander = require("commander");
const pkg = require("./package.json")

const program = commander.program;

program.version(pkg.version).parse(process.argv);
```
在终端执行：commander 打印版本号

注册成功之后 这个命令自动帮助你生成了 --help 的命令可以使用, 并且默认就配置好了 `-V` 这个命令配置version使用

```shell
➜  commander --help
Usage: commander [options]

Options:
  -V, --version  output the version number
  -h, --help     display help for command
```

## 自己初始化一个实例

写法和上一种略有不同,但是显示的效果差不多

```js
const commander = require("commander");
const pkg = require("./package.json")

// 手动实例化一个
const program = new commander.Command()
program.version(pkg.version).parse(process.argv);
```

### usage()、name() 的使用
```js
const commander = require("commander");
const pkg = require("./package.json");

const program = new commander.Command();
program
  .name("wpm-cli")
  .usage("<command> [options]")
  .version(pkg.version)
  .parse(process.argv);
```
添加上述两个方法，打印出来的内容：

```shell
➜  cdn-serve commander --help
Usage: wpm-cli <command> [options]

Options:
  -V, --version  output the version number
  -h, --help     display help for command
```

### options() 方法的使用

```js
const commander = require("commander");
const pkg = require("./package.json");

const program = new commander.Command();
program
  .name("wpm-cli")
  .usage("<command> [options]")
  .option("-d, --debug", "是否启动调试模式", false)
  .version(pkg.version)
  .parse(process.argv);
```
添加上述debug选项的时候，控制台打印

```shell
➜  cdn-serve commander --help 
Usage: wpm-cli <command> [options]

Options:
  -d, --debug    是否启动调试模式 (default: false)
  -V, --version  output the version number
  -h, --help     display help for command
```

### program.opts() 方法
```js
const commander = require("commander");
const pkg = require("./package.json");

const program = new commander.Command();
program
  .name("wpm-cli")
  .usage("<command> [options]")
  .option("-d, --debug", "是否启动调试模式", false)
  .option("-e, --env", "打印env信息", true)
  .version(pkg.version)
  .parse(process.argv);

console.log(program.opts()); // { debug: false, env: true }
```

从打印的信息可以看到，在新的版本的  commander 中只能从 opts() 方法中获取自定义配置信息了。


## commander 最两种注册命令的方式

### 调用 command 这种方式
先看代码:
```js
const commander = require("commander");
const pkg = require("./package.json");

const program = new commander.Command();
program
  .name("wpm-cli")
  .usage("<command> [options]")
  .option("-d, --debug", "是否启动调试模式", false)
  .option("-e, --env", "打印env信息", true)
  .version(pkg.version);

// 注册clone命令
const clone = program.command("clone <source> [destination]");

clone
  .description("clone a repository")
  .option("-f, --force", "是否强制克隆")
  .action((source, destination, cmdObj) => {
    console.log("do clone", source, destination, cmdObj.force);
  });

program.parse(process.argv);
```

上面代码中，使用 `program.command("clone <source> [destination]");` 注册了一个clone 命令，注意这个命令和全局的命令是分开的，意思是可以单独执行 clone 命令。 

终端执行 `commander clone --help` 显示clone的使用方式

```shell
➜  cdn-serve commander clone  --help
Usage: wpm-cli clone [options] <source> [destination]

clone a repository

Options:
  -f, --force  是否强制克隆
  -h, --help   display help for command
```

### 调用 addCommand 注册命令
先看代码：

```js
const commander = require("commander");
const pkg = require("./package.json");

const program = new commander.Command();
program
  .name("wpm-cli")
  .usage("<command> [options]")
  .option("-d, --debug", "是否启动调试模式", false)
  .option("-e, --env", "打印env信息", true)
  .version(pkg.version);

// 注册子命令
const service = new commander.Command("service");

service
  .command("start [port]")
  .description("start service at some port")
  .action((port) => {
    console.log("do service start", port);
  });

program.addCommand(service);
program.parse(process.argv);
```

上述代码中注册了service的子命令，通过这种思路，很多子命令都是可以单独封装的

## 继续开发项目

首先需要在core/cli中添加命令注册的相关的内容。
- 首先安装使用 `lerna add commander@8.0.0 core/cli` 安装依赖。

```js
// ...
const commander = require("commander")
// ...
const program = new commander.Command()

// 注册命令方法
function registerCommand() {
  program
    .version(pkg.version)
  program.parse(process.argv)
}
```
上述函数书写完毕，调用之后，使用 `cdp-wpm -h` 会在控制台打印

```
➜  cli git:(master) ✗ cdp-wpm -h            
cdp-wpm info cli 0.0.14
/Users/louis/.cdp-wpm
Usage: cdp-wpm [options]

Options:
  -V, --version  output the version number
  -h, --help     display help for command
```

我们再完善一些信息，添加name、添加一个usage

```js
function registerCommand() {
  program
    .name(Object.keys(pkg.bin)[0]) // 从 pkg 中
    .usage("<command> [options]")
    .version(pkg.version)
    .option("-d, --debug", "是否开启调试模式", false)
  program.parse(process.argv)
}
```
执行 `cdp-wpm -h`, 控制台输出

```
➜  cli git:(master) ✗ cdp-wpm -h
cdp-wpm info cli 0.0.14
/Users/louis/.cdp-wpm
Usage: cdp-wpm <command> [options]

Options:
  -V, --version  output the version number
  -d, --debug    是否开启调试模式 (default: false)
  -h, --help     display help for command
```

这里在开发的时候遇到了一个问题, 我们想要测试debug命令的时候，想要获取输入的命令，需要使用`opts`方法。

```js
program.on("option:debug", function() {
  const opts = program.opts()
  const {debug} = opts
  if (debug) {
    process.env.LOG_LEVEL = "verbose"
  } else {
    process.env.LOG_LEVEL = "info"
  }
  log.level = process.env.LOG_LEVEL
  log.verbose("debug")
})
```

### 注册子命令 init
这部分主要是涉及到初始化的init命令注册的逻辑实现。

```js
program
  .command("init [projectName]")
  .option("-f, --force", "是否强制初始化项目")
  .action((projectName, cmdObj) => {
    console.log("init", projectName, cmdObj.force)
})
```

输入 `cdp-wpm init test --force`

```shell
➜  cdp-wpm-cli git:(master) ✗ cdp-wpm init test --force
cdp-wpm info cli 0.0.14
/Users/louis/.cdp-wpm
init test true
```

### 将init action 拆分抽离到 commands 目录下面

使用lerna创建一个 init 项目, 我修改了 `lerna.json` 文件

```shell
lerna create @cdp-wpm/init 
```

将action中的init逻辑抽离到单独的包中，方便维护。


### 脚手架目前的痛点难点分析

上面我们的架构设计已经能够满足一般脚手架的需求，但是还是有以下两个问题:
- cli速度慢：所有的pak都集成在 cli 里面，因此当 命令较多的时候，会减慢cli的安装速度。
- 灵活性比较差：init命令只能使用 `@cdp-wpm/init`包，对于集团公司而言，每个bu的init命令可能都不相同，可能需要实现init命令动态化。例如：
  - 团队A使用`@cdp-wpm/init`作为初始化模块
  - 团队B使用`@cdp-wpm/my-init`作为初始化模块
  - 团队C使用`@cdp-wpm/your-init`作为初始化模块

这个时候对于我们架构设计自己的脚手架就提出了挑战，要求我们能够动态的加载init模块，这将增加架构的难度，但是会大大提升脚手架的可扩展性，将脚手架框架和业务逻辑做解耦。

也就是说，我们在core中引用的init模块，不能写死，而是需要动态的去引用。

根据老师的说法，解耦之后 init 模块可以单独去下载，core 模块本身速度就比较快了。

我们在执行命令的时候，可以通过node多进程来执行命令，充分利用cpu, 也能提升性能。

### 添加一个 targetPath 的 option

这个option和 debug 命令一样，是一个全局的option 如果想要获得 执行命令的参数，需要从 program.opts() 这个方法中获取。

action 这个方法中接收一个回调函数作为参数，他其实就是执行这个函数的，我们传入init 也好，传入一个箭头函数也好，都是一个意思，如果在箭头函数执行一个函数，这种思想就是面向切面编程，学以致用 done！

当然还有一种实现方案：使用环境变量的解决方案，环境变量是依托于当前操作系统的。

这是一种通过环境变量实现业务解耦的实践，非常棒。
















 


















